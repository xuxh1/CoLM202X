#include <define.h>

MODULE MOD_Block

   !-------------------------------------------------------------------------------------
   ! DESCRIPTION:
   !
   !    To deal with high-resolution data, the globe is divided into blocks.
   !
   !     (180W,90N)                           (180E,90N)
   !        .-----------------------------------.
   !        |         |         |        |      |
   !        |         |         |        |      |
   !        |         |         |        |      |
   !        .-----------------------------------.
   !        |         |         |        |      |
   !        |         |         |        |      |
   !        |         |         |        |      |
   !        .-----------------------------------.
   !        |         |         |        |      |
   !        |         |         |        |      |
   !        |         |         |        |      |
   !        .-----------------------------------.
   !     (180W,90S)                           (180E,90S)
   !   
   !    1.
   !    Boundaries for block (i,j) is saved in 
   !    "gblock%lat_s(j), gblock%lat_n(j), gblock%lon_w(i), gblock%lon_e(i)" 
   !    for south, north, west and east boundaries respectively.
   !
   !    2.
   !    The (i,j) element of 2D array gblock%pio saves the global communication
   !    number of process which is in charge of Input/Output of block (i,j).
   !
   !    3.
   !    For Input/Output processes, "gblock%nblkme, gblock%xblkme(:), gblock%yblkme(:)"
   !    save the locations of blocks which are handled by themselves.
   !
   !    4.
   !    Division of blocks can be generated by number of blocks globally (by set_by_size), 
   !    or set by predefined boundaries in files (by set_by_file).
   ! 
   ! Created by Shupeng Zhang, May 2023
   !-------------------------------------------------------------------------------------

   USE MOD_Precision
   IMPLICIT NONE

   ! ---- data types ----
   TYPE :: block_type

      ! Coordinates.
      INTEGER :: nxblk, nyblk
      REAL(r8), allocatable :: lat_s (:)
      REAL(r8), allocatable :: lat_n (:)
      REAL(r8), allocatable :: lon_w (:)
      REAL(r8), allocatable :: lon_e (:)

      ! IO.
      INTEGER, allocatable :: pio(:,:)
   
      INTEGER :: nblkme
      INTEGER, allocatable :: xblkme(:), yblkme(:)

   CONTAINS

      procedure, PUBLIC :: set_by_size => block_set_by_size
      procedure, PUBLIC :: set_by_file => block_set_by_file

      procedure, PUBLIC :: save_to_file   => block_save_to_file
      procedure, PUBLIC :: load_from_file => block_load_from_file
      
      procedure, PRIVATE :: clip     => block_clip
      procedure, PRIVATE :: init_pio => block_init_pio
      procedure, PRIVATE :: read_pio => block_read_pio

      final :: block_free_mem

   END TYPE block_type

   ! ---- Instance ----
   TYPE (block_type) :: gblock
   

   ! ---- PUBLIC SUBROUTINE ----
   PUBLIC :: get_filename_block

CONTAINS

   ! --------------------------------
   SUBROUTINE block_set_by_size (this, nxblk_in, nyblk_in)
      
      USE MOD_Precision
      USE MOD_Namelist
      USE MOD_Utils
      USE MOD_SPMD_Task
      IMPLICIT NONE

      class (block_type) :: this
      INTEGER,  intent(in) :: nxblk_in, nyblk_in

      ! Local Variables
      INTEGER  :: iblk, jblk
      INTEGER, parameter :: iset(24) = &
         (/1,  2,  3,  4,  5,  6,  8,  9, 10,  12,  15,  18, &
          20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180, 360/)

      IF ((findloc(iset,nyblk_in,dim=1) <= 0) .or. &
         (findloc(iset,nxblk_in,dim=1) <= 0) ) THEN

         IF (p_is_master) THEN
            write(*,*) 'Number of blocks should be in the set (', iset, ')'
         ENDIF

#ifdef USEMPI
         CALL mpi_barrier (p_comm_glb, p_err)
         CALL mpi_abort   (p_comm_glb, p_err)
#endif

      ENDIF

      this%nxblk = nxblk_in
      this%nyblk = nyblk_in

      allocate (this%lon_w (this%nxblk))
      allocate (this%lon_e (this%nxblk))
      
      DO iblk = 1, this%nxblk
         this%lon_w(iblk) = -180.0 + 360.0/this%nxblk * (iblk-1) 
         this%lon_e(iblk) = -180.0 + 360.0/this%nxblk * iblk

         CALL normalize_longitude (this%lon_w(iblk))
         CALL normalize_longitude (this%lon_e(iblk))
      ENDDO

      allocate (this%lat_s (this%nyblk))
      allocate (this%lat_n (this%nyblk))

      DO jblk = 1, this%nyblk
         this%lat_s(jblk) = -90.0 + 180.0/this%nyblk * (jblk-1) 
         this%lat_n(jblk) = -90.0 + 180.0/this%nyblk * jblk
      ENDDO

      IF (p_is_master) THEN
         write (*,*) 'Block information:'
         write (*,'(I3,A,I3,A)') this%nxblk, ' blocks in longitude,', &
            this%nyblk, ' blocks in latitude.'
         write (*,*)
      ENDIF

      CALL this%init_pio ()

   END SUBROUTINE block_set_by_size

   ! --------------------------------
   SUBROUTINE block_set_by_file (this, block_file)

      USE MOD_NetCDFSerial
      USE MOD_SPMD_Task
      IMPLICIT NONE

      class (block_type) :: this
      CHARACTER(len=*),  intent(in) :: block_file

      ! Local variables
      CHARACTER(len=256) :: filename
         
      filename = trim(block_file)
         
      CALL ncio_read_bcast_serial (filename, 'lat_s', this%lat_s)
      CALL ncio_read_bcast_serial (filename, 'lat_n', this%lat_n)
      CALL ncio_read_bcast_serial (filename, 'lon_w', this%lon_w)
      CALL ncio_read_bcast_serial (filename, 'lon_e', this%lon_e)
         
      this%nyblk = size(this%lat_s)
      this%nxblk = size(this%lon_w)

      ! blocks should be from south to north
      IF (this%lat_s(1) > this%lat_s(this%nyblk)) THEN
         this%lat_s = this%lat_s(this%nyblk:1:-1)
         this%lat_n = this%lat_n(this%nyblk:1:-1)
      ENDIF
      
      IF (p_is_master) THEN
         write (*,*) 'Block information:'
         write (*,'(I3,A,I3,A)') this%nxblk, ' blocks in longitude,', &
            this%nyblk, ' blocks in latitude.'
         write (*,*)
      ENDIF

      CALL this%init_pio ()

   END SUBROUTINE block_set_by_file

   ! --------------------------------
   SUBROUTINE block_save_to_file (this, dir_landdata)

      USE MOD_NetCDFSerial
      USE MOD_SPMD_Task
      IMPLICIT NONE

      class (block_type) :: this

      CHARACTER(len=*), intent(in) :: dir_landdata

      ! Local variables
      CHARACTER(len=256) :: filename
      
      IF (p_is_master) THEN
         
         filename = trim(dir_landdata) // '/block.nc'

         CALL ncio_create_file (filename)

         CALL ncio_define_dimension (filename, 'longitude', this%nxblk)
         CALL ncio_define_dimension (filename, 'latitude',  this%nyblk)

         CALL ncio_write_serial (filename, 'lat_s', this%lat_s, 'latitude' )
         CALL ncio_write_serial (filename, 'lat_n', this%lat_n, 'latitude' )
         CALL ncio_write_serial (filename, 'lon_w', this%lon_w, 'longitude')
         CALL ncio_write_serial (filename, 'lon_e', this%lon_e, 'longitude')

      ENDIF

   END SUBROUTINE block_save_to_file

   ! --------------------------------
   SUBROUTINE block_load_from_file (this, dir_landdata)

      USE MOD_NetCDFSerial
      USE MOD_SPMD_Task
      IMPLICIT NONE

      class (block_type) :: this
      CHARACTER(len=*),  intent(in) :: dir_landdata

      ! Local variables
      CHARACTER(len=256) :: filename
         
      filename = trim(dir_landdata) // '/block.nc'
         
      CALL ncio_read_bcast_serial (filename, 'lat_s', this%lat_s)
      CALL ncio_read_bcast_serial (filename, 'lat_n', this%lat_n)
      CALL ncio_read_bcast_serial (filename, 'lon_w', this%lon_w)
      CALL ncio_read_bcast_serial (filename, 'lon_e', this%lon_e)
         
      this%nyblk = size(this%lat_s)
      this%nxblk = size(this%lon_w)
      
      IF (p_is_master) THEN
         write (*,*) 'Block information:'
         write (*,'(I3,A,I3,A)') this%nxblk, ' blocks in longitude,', &
            this%nyblk, ' blocks in latitude.'
         write (*,*)
      ENDIF

      CALL this%read_pio (dir_landdata)

   END SUBROUTINE block_load_from_file

   ! --------------------------------
   SUBROUTINE block_clip (this, &
         iblk_south, iblk_north, iblk_west, iblk_east, numblocks)
     
      USE MOD_Namelist
      USE MOD_Utils
      IMPLICIT NONE 
      
      class (block_type) :: this
      INTEGER, intent(out) :: iblk_south, iblk_north, iblk_west, iblk_east
      INTEGER, intent(out), optional :: numblocks

      ! Local Variables
      REAL(r8) :: edges, edgen, edgew, edgee
      INTEGER  :: numblocks_x, numblocks_y

      edges = DEF_domain%edges
      edgen = DEF_domain%edgen
      edgew = DEF_domain%edgew
      edgee = DEF_domain%edgee

      iblk_south = find_nearest_south (edges, this%nyblk, this%lat_s)
      iblk_north = find_nearest_north (edgen, this%nyblk, this%lat_n)

      CALL normalize_longitude (edgew)
      CALL normalize_longitude (edgee)

      IF (edgew == edgee) THEN
         iblk_west = 1
         iblk_east = this%nxblk
      ELSE
         iblk_west = find_nearest_west (edgew, this%nxblk, this%lon_w)
         iblk_east = find_nearest_east (edgee, this%nxblk, this%lon_e)

         IF (iblk_west == iblk_east) THEN
            IF (lon_between_floor(edgee,this%lon_w(iblk_west),edgew)) THEN
               iblk_west = 1
               iblk_east = this%nxblk
            ENDIF
         ENDIF
      ENDIF

      IF (present(numblocks)) THEN
        
         numblocks_y = iblk_north - iblk_south + 1
         
         IF (iblk_east >= iblk_west) THEN
            numblocks_x = iblk_east - iblk_west + 1
         ELSE
            numblocks_x = this%nxblk - iblk_west + 1 + iblk_east
         ENDIF

         numblocks = numblocks_x * numblocks_y

      ENDIF

   END SUBROUTINE block_clip

   ! --------------------------------
   SUBROUTINE block_init_pio (this)
      
      USE MOD_Precision
      USE MOD_SPMD_Task
      USE MOD_Namelist
      USE MOD_Utils
#ifdef SinglePoint
      USE MOD_SingleSrfdata
#endif
      IMPLICIT NONE

      class (block_type) :: this
      
      INTEGER :: iblk, jblk, iproc
      INTEGER :: iblk_south, iblk_north, iblk_west, iblk_east
      INTEGER :: numblocks
      INTEGER :: iblkme

      IF (p_is_master) THEN
         CALL this%clip (iblk_south, iblk_north, iblk_west, iblk_east, numblocks)
      ENDIF
      
#ifdef USEMPI
      CALL mpi_bcast (numblocks, 1, MPI_INTEGER, p_root, p_comm_glb, p_err)
      CALL divide_processes_into_groups (numblocks, DEF_PIO_groupsize)
#endif 

      allocate (this%pio (this%nxblk,this%nyblk))

      IF (p_is_master) THEN
      
         this%pio(:,:) = -1

         iproc = -1
         DO jblk = iblk_south, iblk_north

            iblk = iblk_west
            DO while (.true.)
#ifdef USEMPI
               iproc = mod(iproc+1, p_np_io)
               this%pio(iblk,jblk) = p_address_io(iproc)
#else
               this%pio(iblk,jblk) = p_root
#endif 

               IF (iblk /= iblk_east) THEN
                  iblk = mod(iblk,this%nxblk) + 1
               ELSE
                  exit
               ENDIF
            ENDDO
         ENDDO

      ENDIF

#ifdef USEMPI
      CALL mpi_bcast (this%pio, this%nxblk * this%nyblk, MPI_INTEGER, &
         p_root, p_comm_glb, p_err)
#endif 

#ifndef SinglePoint
      this%nblkme = 0
      IF (p_is_io) THEN
         this%nblkme = count(this%pio == p_iam_glb)
         IF (this%nblkme > 0) THEN
            iblkme = 0
            allocate (this%xblkme(this%nblkme))
            allocate (this%yblkme(this%nblkme))
            DO iblk = 1, this%nxblk
               DO jblk = 1, this%nyblk
                  IF (p_iam_glb == this%pio(iblk,jblk)) THEN
                     iblkme = iblkme + 1
                     this%xblkme(iblkme) = iblk
                     this%yblkme(iblkme) = jblk
                  ENDIF
               ENDDO
            ENDDO
         ENDIF
      ENDIF
#else
      this%nblkme = 1
      allocate(this%xblkme(1))
      allocate(this%yblkme(1))

      CALL normalize_longitude (SITE_lon_location)
      this%xblkme(1) = find_nearest_west  (SITE_lon_location, this%nxblk, this%lon_w)

      this%yblkme(1) = find_nearest_south (SITE_lat_location, this%nyblk, this%lat_s)
#endif

   END SUBROUTINE block_init_pio

   ! --------------------------------
   SUBROUTINE block_read_pio (this, dir_landdata)
         
      USE MOD_SPMD_Task
      USE MOD_NetCDFSerial
      USE MOD_Namelist
      IMPLICIT NONE

      class (block_type) :: this
      CHARACTER(len=*),  intent(in) :: dir_landdata

      ! Local Variables
      CHARACTER(len=256) :: filename, cyear
      INTEGER, allocatable :: nelm_io(:), nelmblk(:,:)
      INTEGER  :: iblk_south, iblk_north, iblk_west, iblk_east
      INTEGER  :: numblocks, iblk, jblk, iproc, jproc
      INTEGER  :: iblkme
      
      IF (p_is_master) THEN
         ! Whether it varies by year???
         write(cyear,'(i4.4)') DEF_LC_YEAR
         filename = trim(dir_landdata) // '/mesh/' // trim(cyear) // '/mesh.nc'
         CALL ncio_read_serial (filename, 'nelm_blk', nelmblk)
         numblocks = count(nelmblk > 0)
      ENDIF 
      
      IF (p_is_master) THEN
         CALL this%clip (iblk_south, iblk_north, iblk_west, iblk_east)
      ENDIF

#ifdef USEMPI
      CALL mpi_bcast (numblocks, 1, MPI_INTEGER, p_root, p_comm_glb, p_err)
      CALL divide_processes_into_groups (numblocks, DEF_PIO_groupsize)
#endif
      
      allocate (this%pio (this%nxblk,this%nyblk))

      IF (p_is_master) THEN

         this%pio(:,:) = -1

#ifdef USEMPI
         allocate (nelm_io (0:p_np_io-1))
         nelm_io(:) = 0
         jproc = -1
#endif

         DO jblk = iblk_south, iblk_north
            iblk = iblk_west
            DO while (.true.)
#ifdef USEMPI
               IF (nelmblk(iblk,jblk) > 0) THEN
                  iproc = minloc(nelm_io, dim=1) - 1
                  this%pio(iblk,jblk) = p_address_io(iproc)
                  nelm_io(iproc) = nelm_io(iproc) + nelmblk(iblk,jblk)
               ELSEIF (nelmblk(iblk,jblk) == 0) THEN
                  jproc = mod(jproc+1, p_np_io)
                  this%pio(iblk,jblk) = p_address_io(jproc)
               ENDIF
#else
               this%pio(iblk,jblk) = p_root
#endif
               
               IF (iblk /= iblk_east) THEN
                  iblk = mod(iblk,this%nxblk) + 1
               ELSE
                  exit
               ENDIF
            ENDDO
         ENDDO

#ifdef USEMPI
         deallocate (nelm_io)
#endif
      ENDIF

#ifdef USEMPI
      CALL mpi_bcast (this%pio, this%nxblk * this%nyblk, MPI_INTEGER, &
         p_root, p_comm_glb, p_err)
#endif
      
#ifndef SinglePoint
      this%nblkme = 0
      IF (p_is_io) THEN
         this%nblkme = count(this%pio == p_iam_glb)
         IF (this%nblkme > 0) THEN
            iblkme = 0
            allocate (this%xblkme(this%nblkme))
            allocate (this%yblkme(this%nblkme))
            DO iblk = 1, this%nxblk
               DO jblk = 1, this%nyblk
                  IF (p_iam_glb == this%pio(iblk,jblk)) THEN
                     iblkme = iblkme + 1
                     this%xblkme(iblkme) = iblk
                     this%yblkme(iblkme) = jblk
                  ENDIF
               ENDDO
            ENDDO
         ENDIF
      ENDIF
#else
      this%nblkme = 1
      allocate(this%xblkme(1))
      allocate(this%yblkme(1))
         
      DO jblk = 1, this%nyblk
         DO iblk = 1, this%nxblk
            IF (nelmblk(iblk,jblk) > 0) THEN
               this%xblkme(1) = iblk
               this%yblkme(1) = jblk
            ENDIF
         ENDDO
      ENDDO
#endif

      IF (allocated(nelmblk)) deallocate (nelmblk)

   END SUBROUTINE block_read_pio

   ! --------------------------------
   SUBROUTINE block_free_mem (this)

      IMPLICIT NONE
      TYPE (block_type) :: this

      IF (allocated (this%lat_s))  deallocate (this%lat_s)
      IF (allocated (this%lat_n))  deallocate (this%lat_n)
      IF (allocated (this%lon_w))  deallocate (this%lon_w)
      IF (allocated (this%lon_e))  deallocate (this%lon_e)
      
      IF (allocated (this%pio)  )  deallocate (this%pio  )

      IF (allocated (this%xblkme)) deallocate (this%xblkme)
      IF (allocated (this%yblkme)) deallocate (this%yblkme)
      
   END SUBROUTINE block_free_mem
   
   ! --------------------------------
   SUBROUTINE get_filename_block (filename, iblk, jblk, fileblock)
      
      IMPLICIT NONE

      CHARACTER(len=*), intent(in) :: filename
      INTEGER, intent(in) :: iblk, jblk

      CHARACTER(len=*), intent(out) :: fileblock

      ! Local variables
      CHARACTER(len=4) :: cx
      CHARACTER(len=3) :: cy
      INTEGER :: i

      IF (gblock%lat_s(jblk) < 0) THEN
         write (cy, '(A1,I2.2)') 's', - floor(gblock%lat_s(jblk))
      ELSE
         write (cy, '(A1,I2.2)') 'n',   floor(gblock%lat_s(jblk))
      ENDIF

      IF (gblock%lon_w(iblk) < 0) THEN
         write (cx, '(A1,I3.3)') 'w', - floor(gblock%lon_w(iblk))
      ELSE
         write (cx, '(A1,I3.3)') 'e',   floor(gblock%lon_w(iblk))
      ENDIF

      i = len_trim (filename) 
      DO while (i > 0)
         IF (filename(i:i) == '.') exit
         i = i - 1
      ENDDO

      IF (i > 0) THEN
         fileblock = filename(1:i-1) // '_' // trim(cx) // '_' // trim(cy) // '.nc'
      ELSE
         fileblock = filename // '_' // trim(cx) // '_' // trim(cy) // '.nc'
      ENDIF

   END SUBROUTINE get_filename_block 

END MODULE MOD_Block
